[{"content":"1. 背景 以前就听过 Rime 输入法的大名，可以根据自己的喜好自定义输入法。但是看到复杂的配置教程，就被劝退了，多年使用的搜狗输入法去广告版也是 OK 的。\n前两天刷 X，看到有人推荐了一个叫作oh-my-rime 的 Rime 快速初始化模板，就又心痒痒了起来，想要试一下大名鼎鼎的 Rime 输入法。\n虽然这个模板介绍中详细介绍了如何部署，但还是想记录以下我在部署过程中遇到的问题，以及一些优化。\n2. Rime 输入法 RIME 的全称是「RIME 中州韵输入法引擎 」，严格来讲，RIME 本身并不是输入法，而是一套为输入法专门开发的核心算法。由于 RIME 的代码是开源的，所以理论上任何人都可以将其修改、打包成属于自己的输入法。\nRIME 在不同的操作系统上都有较为成熟且知名的发行版 ——Windows 上叫《小狼毫》，macOS 上叫《鼠须管》，Linux 上叫《ibus-rime》。\nRIME 的最大优势在于开放且可以自定义，这种自定义不限于皮肤、词库等，就连输入方案本身都能自建。正因如此，RIME 上有许多较为冷门的输入方案，如中古汉语拼音、粤拼、吴语等。同时，RIME 还能加载字形转换引擎，实现诸如「简化字 ⁠–传统汉字」「香港字形 ⁠–台湾字形」等字形变换。\n安装 Rime 本人使用 windows 电脑，官网下载地址： Rime 下载 下载后直接安装\n安装路径可以默认，也可以自定义，用户资料文件夹也可自定义「如果自定义则需要记住，后面需要使用」\n安装后自动弹出配置\n可以选择多种方案，如果没有想要的方案，可以点击获取更多方案，或安装后导入方案。\n3. oh-my-rime 输入法 oh-my-rime 的作者是一个深度使用 rime 的大佬，其自定义总结出来 oh-my-rime，开源给大家使用，在这里表示感谢 💖。\noh-my-rime 借鉴了很多雾凇拼音的地方，同时整合了雾凇拼音词库，98 五笔词库，emoji 词库，颜文字词库。\noh-my-rime 支持小鹤双拼，以及支持小鹤音形，这也是我选择用它的主要理由。 安装方法 根据官方介绍的方法，部署十分简单：\n在安装好 Rime 之后，下载 oh-my-rime Git 仓库 中的文件， 然后全部解压到本地 rime 配置文件夹中\nWindows 默认：%APPDATA%\\Rime 或你自定义的文件夹 解压之后，在 Rime 输入法的图标上 「右键-重新部署」，等待几分钟之后，即可使用。\nTips 对了，小鹤音形只能在小鹤双拼中使用，触发键为「 ; 」。薄荷拼音-小鹤混熟状态下无法使用小鹤音形。\n4. 一点小问题 重启失效 本人是 win11 电脑，在重启电脑后发现 Rime 不见了，切换输入法中没有 Rime。\n解决方案：需要在设置中手动添加上 Rime 输入法。\n只能输入英文 再次重启后，可以选择上Rime了，但是只能打英文，没有中文输入框。这是由于Rime服务程序没有开机启动成功，虽然是开机启动项。（这个问题可能是个例）\n解决方案：在开机启动中添加WeaselServer.exe的快捷启动。\n开机启动文件夹路径： C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n5. 优化美化 调整输入法 如果你想定制、调整输入法，可以在对应输入法的yaml中进行修改\n比如你想调整小鹤双拼中小鹤音形的激活码，可以打开小鹤双拼的语法配置文件double_pinyin_flypy.schema.yaml ，修改其中的音形配置。\nStyle样式 Rime的样式文件为weasel.custom.yaml（mac: squirrel.custom.yaml） ，其中包含几乎所有的样式配置，譬如可以修改字体，字体大小，候选词的排列方向等等\noh-my-rime中自带皮肤在我的windows电脑上有一点样式问题，输入区和候选词的第一词的背景比整体的背景大几个像素，为此我添加了边框宽度，把这部分遮挡住。\n这是修改后 6. 小结 虽然截止目前，我只使用了不到一天，但是体验还是不错的。\n除了如果打字快的时候，候选词显示跟不上打字速度，而搜狗就能完美跟上，其他倒是没有影响。\n如果感兴趣，记得试一试。\n7. 参考资料 oh-my-rime 输入法 | 薄荷输入法 跨平台、无隐私追踪的开源输入法Rime定制指南: 聪明的输入法懂我心意!_哔哩哔哩_bilibili rime自定义皮肤 ","permalink":"https://ryanwooa.github.io/zh/posts/life/rime+xiaohe/","summary":"1. 背景 以前就听过 Rime 输入法的大名，可以根据自己的喜好自定义输入法。但是看到复杂的配置教程，就被劝退了，多年使用的搜狗输入法去广告版也是 OK 的。 前","title":"Rime + 小鹤双拼"},{"content":"class Me: def __init__(self): self.name = \u0026#34;Ryan Wu\u0026#34; self.born_year = 1993 self.MBTI = INTJ self.hometown = \u0026#34;Baoji, Shaanxi, CN\u0026#34; self.curr_location = \u0026#34;Auckland, NZ\u0026#34; self.grad_school = \u0026#34;University of Auckland\u0026#34; self.undergrad_school = \u0026#34;Nanjing University of Aeronautics and Astronautics\u0026#34; 致力于成为一名优秀的软件工程师，热爱编程，热爱开源，热爱分享。\n","permalink":"https://ryanwooa.github.io/zh/about/","summary":"class Me: def __init__(self): self.name = \u0026#34;Ryan Wu\u0026#34; self.born_year = 1993 self.MBTI = INTJ self.hometown = \u0026#34;Baoji, Shaanxi, CN\u0026#34; self.curr_location = \u0026#34;Auckland, NZ\u0026#34; self.grad_school = \u0026#34;University of Auckland\u0026#34; self.undergrad_school = \u0026#34;Nanjing University of Aeronautics and Astronautics\u0026#34; 致力于成为一名优秀的软件工程师，热爱编程，热爱开源，热爱分享。","title":"关于我 😎"},{"content":"1. 外观类 1.1 主题文件位置调整 在安装好主题后，可以将下图圈出来的文件复制到站点对应的目录下，这样就可以自定义博客的样式，而不会影响主题的更新。\nHugo在加载时会优先读取站点目录下的文件，如果没有则读取theme目录下的文件。\n1.2 侧边目录栏 替换 layouts/partials/toc.html 中的代码为以下内容： {{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 在/assets/css/extended/blank.css中添加以下样式 :root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } 参考链接: Hugo博客目录放在侧边 | PaperMod主题 1.3 修改字体 在static/fonts/目录下添加想要使用的字体文件\n全局字体 在/assets/css/extended/blank.css中添加以下样式\n@font-face { font-family: circular; src: url(\u0026#34;/fonts/Circular-Book.ttf\u0026#34;) format(\u0026#34;truetype\u0026#34;); } body{ font-family: \u0026#39;circular-book\u0026#39;, sans-serif; } 代码字体 在/assets/css/common/post-single.css中找到.post-content code,添加想要的样式：\n.post-content code { font-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace; } 1.4 代码边框圆角 在/assets/css/common/post-single.css中添加以下样式： .post-content .highlight pre { background-color: var(--theme) !important; margin: 0; } 块引用的圆角样式依然在该文件中，修改以下样式： .post-content code { border-radius: 6px; } 2. 功能类 2.1 content目录结构调整 content中每个文件夹内都要添加一个 _index.md文件，该文件里面可以用Front Matter 用来控制标题或其它的展示\n. └── content └── about | └── _index.md // \u0026lt;- https://example.com/about/ ├── post | ├── _index.md // \u0026lt;- https://example.com/post/ | ├── firstpost.md // \u0026lt;- https://example.com/post/firstpost/ | ├── happy | | └── ness.md // \u0026lt;- https://example.com/post/happy/ness/ | └── secondpost.md // \u0026lt;- https://example.com/post/secondpost/ └── quote ├── first.md // \u0026lt;- https://example.com/quote/first/ └── second.md // \u0026lt;- https://example.com/quote/second/ 如果你不在文件夹内添加_index.md文件，那么访问该文件夹的时候会直接显示该文件夹下的所有文件，而不会显示文件夹的标题。添加_index.md文件后，访问该文件夹时会显示_index.md文件中的内容。 有时不添加_index.md文件会出现访问路径出错的情况，所以最好还是添加上。 更多参考：Hugo-Content organization 2.2 多语言模式 配置hugo.yml的lauguages为多个语言 languageCode: en-us defaultContentLanguage: en languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: Articles url: posts/ weight: 1 - name: Tags url: tags/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 文章 url: posts/ weight: 1 - name: 标签 url: tags/ weight: 10 - name: 搜索 url: search/ weight: 11 翻译content中的内容, 有两种组织方式： 建立不同语言的文件夹，将对应内容放到对应的文件夹中，如下：\n. └── content ├── en | └── _index.md | └── about.md ├── zh | └── _index.md | └── about.md 我在尝试该方法时，可能是没有设置好文件夹的_index.md文件，所以导致无法显示任何内容，所以采用了下面的方法。\n为每个文件设置多语言版本，例如：\n. └── content └── about | └── _index.md // \u0026lt;- https://example.com/about/ | └── about.en.md | └── about.zh.md 在about.en.md文件中添加title字段，如下：\ntitle: \u0026#34;About\u0026#34; 在about.zh.md文件中添加title字段，如下：\ntitle: \u0026#34;关于\u0026#34; 这样就可以实现多语言切换了。\n更多参考: Hugo-Multilingual Mode 2.3 搜索功能 在content目录下新建search.md文件，内容如下： title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # necessary for search # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;Please enter search content\u0026#34; 配置hugo.yml, 添加以下内容 menu: main: -identifier: Search name: Search url: search weight: ... 随后就可以在nav中看到search选项了，点击即可搜索。\n2.4 评论功能 详见：Hugo博客添加Twikoo评论 2.5 流量统计 使用不蒜子流量统计 ，在/layouts/common/footer.css中对应位置添加如下代码：\n{{- if not (.Param \u0026#34;hideFooter\u0026#34;) }} \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; {{- if site.Copyright }} ... {{- end }} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\u0026#34;\u0026gt; Visitors: \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Views: \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/footer\u0026gt; {{- end }} 随后即可在footer中看到访问量和浏览量。\n3. 优化类 3.1 以新标签页打开链接 在/layouts/_default/_markup/ 下新建render-link.html文件，添加如下内容：\n\u0026lt;a href=\u0026#34;{{ .Destination | safeURL }}\u0026#34;{{ with .Title}} title=\u0026#34;{{ . }}\u0026#34;{{ end }}{{ if strings.HasPrefix .Destination \u0026#34;http\u0026#34; }} target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;{{ end }}\u0026gt;{{ .Text | safeHTML }}\u0026lt;/a\u0026gt; 会自动为所有文章内的链接加上了 target=\u0026quot;_blank\u0026quot; rel=\u0026quot;noopener\u0026quot;\n参考链接：\n在 Hugo Goldmark Markdown 中设置以新标签打开链接 Hugo - Markdown render hooks ","permalink":"https://ryanwooa.github.io/zh/posts/tech/customize_hugo/","summary":"1. 外观类 1.1 主题文件位置调整 在安装好主题后，可以将下图圈出来的文件复制到站点对应的目录下，这样就可以自定义博客的样式，而不会影响主题的更新。 H","title":"Hugo + PaperMod 美化整理"},{"content":"1. 介绍 1.1 什么是Hugo Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator），可以把 Markdown 文件转化成 HTML 文件。具有简单、易用、高效、易扩展、快速部署的特点。\n1.2 什么是Github Pages GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。 用户可以在 GitHub 的 github.io 域或自己的自定义域上托管站点。\nGithub Pages用户手册 2. 准备工作 这篇教程假设你已经了解了Git和Github的基本使用，如果不了解，可以参考 廖雪峰的Git教程 。\n2.1 运行环境 你需要安装以下环境：\nGit Hugo 自己习惯使用的IDE，比如VSCode 2.2 安装Hugo 本人使用的是Windows11系统，安装过程参考如下：\nHugo是使用Go语言编写，所以需要先安装Go语言环境，Go语言下载地址 下载对应版本的Hugo二进制文件，Hugo下载地址 (本文发布日期：2024-2-11，如有新版请自行更新) 解压下载的Hugo压缩包，将hugo.exe文件添加到你的PATH环境变量中 打开命令行，输入hugo version，如果显示版本号则安装成功 其他系统的Hugo安装可以参考Hugo安装教程 2.3 创建Github仓库 创建2个Github仓库，一个用于储存Hugo博客源码，一个用于储存Hugo生成的静态网页。\n创建Github Pages仓库 命名为\u0026lt;username\u0026gt;.github.io，其中\u0026lt;username\u0026gt;是你的Github用户名，这个仓库用于储存Hugo博客生成的静态网页。 该仓库需要设置为Public，否则无法通过浏览器访问。 勾选添加README文件，这会设置 main 分支为仓库的默认主分支，这在后面提交推送博客内容时很重要。 创建博客源仓库 命名为你想要的名称，这个仓库用于储存Hugo博客的源码。 该仓库可以是Public或Private，根据你的需要设置。 创建完成后将该仓库克隆到本地，作为Hugo创建博客的工作目录。 3. 使用Hugo搭建博客 3.1 初始化Hugo博客 进入克隆下的博客源仓库目录，在PowerShell中运行hugo new site \u0026lt;site_name\u0026gt;，其中\u0026lt;site_name\u0026gt;是你的博客名称\nhugo new site MyFreshWebsite --format yaml --format yaml是指定配置文件格式为yaml格式。该文件格式个人觉得更直观一些\n创建后生成7个主要文件夹和一个文件（图中有后期添加文件夹，仅做参考） archetypes: 存放新文章的模板 content: 博客文章内容 data: 存放数据文件的文件夹，不用管 layouts: 自定义HTML public: 存放生成的静态网页 static: 存放静态文件,如图片，图标等 themes: 存放主题 hugo.yml: 博客配置文件 3.2 hugo.yml配置 打开hugo.yml文件，参考配置如下：\nbaseURL: \u0026#34;https://\u0026lt;yourname\u0026gt;.github.io/\u0026#34; # 你的Github Pages地址 languageCode: en-us title: \u0026lt;Your Nmae\u0026gt; # 你的博客名称 theme: \u0026lt;theme_name\u0026gt; # 你的博客主题 enableInlineShortcodes: true #允许内联短码 enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启 buildDrafts: false buildFuture: false buildExpired: false #googleAnalytics: UA-123-45 # 谷歌统计 # Copyright: Sulv paginate: 15 # 每页显示的文章数 minify: disableXML: true minifyOutput: true permalinks: #浏览器链接显示方式 post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: en # 最顶部首先展示的语言页面 defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; weight: 1 menu: main: - name: Articles url: posts/ weight: 1 - name: Tags url: tags/ weight: 10 - name: Search url: search/ weight: 11 zh: languageName: \u0026#34;中文\u0026#34; weight: 2 menu: main: - name: 文章 url: posts/ weight: 1 - name: 标签 url: tags/ weight: 10 - name: 搜索 url: search/ weight: 11 params: socialIcons: - name: github title: View Source on Github url: \u0026#34;https://github.com/ryanwooa\u0026#34; - name: Instagram # title: Share PaperMod on X/Twitter url: \u0026#34;https://www.instagram.com/ryanwu5_/\u0026#34; - name: X title: url: \u0026#34;https://twitter.com/nzw897\u0026#34; - name: linkedin title: url: \u0026#34;https://www.linkedin.com/in/ryan-wu-9b8161268/\u0026#34; ShowBreadCrumbs: true ShowRelatedPosts: true ShowPostNavLinks: true ShowCodeCopyButtons: true ShowReadingTime: true label: icon: \u0026#34;q3.png\u0026#34; env: production author: Ryan Wu defaultTheme: auto disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ShowShareButtons: true ShowReadingTime: true # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 assets: favicon: \u0026#34;q3.png\u0026#34; favicon16x16: \u0026#34;q3.png\u0026#34; favicon32x32: \u0026#34;q3.png\u0026#34; apple_touch_icon: \u0026#34;q3.png\u0026#34; safari_pinned_tab: \u0026#34;q3.png\u0026#34; outputs: home: - HTML - RSS - JSON # necessary for search taxonomies: tag: tags category: categories 4. 安装配置Hugo主题 Hugo主题 中提供了很多主题供选择，可以根据自己的喜好选择一个主题。这里以PaperMod 主题为例。\n根据PaperMod安装指南 ，可以通过以下命令安装PaperMod主题：\ngit submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 这时可以看到在themes文件夹中，多出了刚刚安装的主题文件，代表主题安装成功。（如果安装路径不太对，可以手动移到到theme文件夹下) 在hugo.yml文件中添加下面的语句配置主题：\ntheme: PaperMod 更多PaperMod配置可以参考PaperMod特性 5. 用Hugo创建新文章 Hugo中创建新文章非常简单，只需要在终端中输入以下命令：\nhugo new xxx.md hugo new posts/xxx.md #可以指定文章的目录 使用该命令创建的Markdown文件中会自动包含一些基本的信息，如文章标题、日期等。可以在Markdown文件中编辑文章内容。 draft = true 指这篇文章目前为草稿, 如果希望文章在网站上显示，需要将draft设置为false或删除该行\n6. 本地调试预览 在创建好Hugo网站后，可以通过以下命令在本地预览网站：\nhugo server 本地预览网址为localhost:1313\n7. 使用Github Action部署到Github Pages GitHub Actions 是一种持续集成和持续交付 (CI/CD) 平台，可用于自动执行生成、测试和部署管道。 本文使用Github Action自动部署Hugo博客到Github Pages。\n7.1 配置Workflow 在项目根目录下创建.github/workflows文件夹，以.yml 为后缀创建workflow文件。我的 GitHub Action 自动发布文件main.yml示例配置如下：\nname: GitHub Pages on: push: branches: - main # 博客根目录的默认分支，这里是main，有时也是master pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # 填写你的hugo版本，可用hugo version查看 extended: true # 如果你使用的不是extended版本的hugo，将true改为false - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; # 注意填写main或者master with: personal_token: ${{ secrets.PERSONAL_BLOG}} # 如果secret取了其他名称，将MY_PAT替换掉 external_repository: ryanwooa/ryanwooa.github.io # 填写远程仓库，不一定是这个格式，按照自己的情况写 publish_dir: ./public #cname: www.example.com # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 其中secrets.PERSONAL_BLOG是在GitHub仓库的Settings-\u0026gt;Secrets中添加的个人访问令牌，用于GitHub Action自动部署到GitHub Pages。\n这个令牌在个人账户的Settings-\u0026gt;Developer settings-\u0026gt;Personal access tokens中生成，需要有repo和workflow权限。\n7.2 发布到Github Pages 在完成上述配置后，每次在本地修改完文章后，只需要将修改推送到GitHub仓库，GitHub Action就会将Hugo生成的网页部署到Github Pages仓库中的gh-pages分支下。\n在Github Pages仓库的设置中修改deploy的分支为gh-pages，这样就可以通过https://username.github.io访问自己的博客了。\n8. Reference 如何用 GitHub Pages + Hugo 搭建个人博客 Hugo + GitHub Action，搭建你的博客自动发布系统 [置顶] hugo博客搭建 | PaperMod主题 Hugo官方文档 Github Pages用户手册 ","permalink":"https://ryanwooa.github.io/zh/posts/tech/hugo+papermod/","summary":"1. 介绍 1.1 什么是Hugo Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator），可以把 Markdown 文件转化成 HTML 文件。具有简单、易用、高效、易","title":"Hugo + Github Pages 搭建个人博客"},{"content":"欢迎来到我的博客，这是第一篇文章！很高兴你能来看看。 ","permalink":"https://ryanwooa.github.io/zh/posts/life/helloworld/","summary":"欢迎来到我的博客，这是第一篇文章！很高兴你能来看看。","title":"Hello World"},{"content":"你可以在这里留言。我会尽快回复你。\n👇👇👇\n","permalink":"https://ryanwooa.github.io/zh/messagebox/","summary":"你可以在这里留言。我会尽快回复你。 👇👇👇","title":"留言板 📬"}]